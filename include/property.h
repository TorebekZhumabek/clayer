#ifndef __PROPERTY_H__
#define __PROPERTY_H__

#include <iostream>
#include <set>
#include <tuple>
#include <sstream>
#include <regex>

namespace clayer {

    // Concepts used for property reading and writing
    template<typename T>
    concept bool Streamable = requires(T o, std::ostream& s) {
        {s << o} -> std::ostream&;
    };

    template<typename T>
    concept bool StringRef = requires(T o) {
        {*o} -> std::string;
    };

    // template<typename T=void>
    // void print<>(){
    //     std::cout << "\n";
    // }

    // template<Streamable T, typename... Targs>
    // void print(T o, Targs... tail) {
    //     std::cout << o <<" ";
    //     print(tail...);
    // }

    // ## Log Property - Any item that can be printed in a Log Record
    enum log_properties {
        FILE,   // - File name (CodeContext)
        FUNC,   // - Function name (CodeContext)
        LINE,   // - Line number (CodeContext)
        DATE,   // - Date a Log Record is created (ProgramContext)
        TIME,   // - Time a Log Record is created (ProgramContext)
        MESG    // - Added by the user
    };

    // ### Code Context - Log Properties that can be inferred from Code
    struct CodeContext {
        std::string file;
        std::string func;
        int line;

        CodeContext() = default;
        CodeContext(const std::string& a, const std::string& b, const int& c): file(a), func(b), line(c) {}

        decltype(auto) tie() const{
            return std::tie(file, func, line);
        }
        bool operator<(const CodeContext& rhs) const {
            return tie() < rhs.tie();
        }
    };
    static const std::string CodeContextStart ("");
    static const std::string CodeContextSep (" ");
    static const std::string CodeContextEnd ("");
    std::ostream& operator<<(std::ostream& s, const CodeContext& c) {
        return s << CodeContextStart
            << c.file << CodeContextSep
            << c.func << CodeContextSep
            << c.line << CodeContextEnd;
    }

    // TODO: ProgramContext

    class Property {
    public:
        using State = CodeContext;
        Property() : code() {};

        friend std::ostream& operator<<(std::ostream& s, const Property& c);
        CodeContext code;

        State get_state() {
            return code;
        }

    private:
        // TODO: make code private and try to make read_prop friendly
        // NOTE: lmgtfy.com?q=one cannot declare a namespace within a class 
        // ProgramContext prog;
    };

    template<int N>
    void read_prop(Property& p, std::istringstream s);

    template<>
    void read_prop<FILE>(Property& p, std::istringstream is){
        is >> p.code.file;
    }
    template<>
    void read_prop<FUNC>(Property& p, std::istringstream is){
        is >> p.code.func;
    }

    template<>
    void read_prop<LINE>(Property& p, std::istringstream is){
        is >> p.code.line;
    }

    // TODO: StringRef -> forward iterator on std::string
    template<StringRef PS>
    void read_props(Property& p, PS) {
    }

    template<StringRef PS,int head, int... I>
    void read_props(Property& p, PS ps) {
        read_prop<head>(p, std::istringstream(*ps));
        ps++;
        read_props<PS,I...>(p, ps);
    }

    template<int... I>
    void parse_props(Property& p, std::string& line) {
        std::smatch m;
        std::regex_match(line, m, logger::format_regex);
        read_props<std::smatch::iterator, I...>(p, m.begin()+1);
    }

    // void parse_props(Property& p, std::string& line) {
    //     clayer::parse_props<FILE, FUNC, LINE>(p, line);
    // }

    static std::string PropertyStart ("(");
    static std::string PropertySep (" ");
    static std::string PropertyEnd (")");
    std::ostream& operator<<(std::ostream& s, const Property& c) {
        return s << PropertyStart
            << c.code << PropertyEnd;
    }

    // ### Methods to read Properties for the analyser




    // ### Methods to get Properties
    constexpr char FORMAT[] = "#(#,#)";

    // * Property can be generated by a CodeContext - "Where", or a ProgramContext - "When"
    // TODO: take in contexts
    template<int prop>
    Streamable get_prop();

    template<> Streamable get_prop<FILE>() {return "file";}
    template<> Streamable get_prop<FUNC>() {return "func";}
    template<> Streamable get_prop<LINE>() {return "line";}
    template<> Streamable get_prop<DATE>() {return "date";}
    template<> Streamable get_prop<TIME>() {return "time";}
    // * No overload for MESG that would be added by the user to the stream

    template<typename T = void>
    void print_props();

    template<>
    void print_props<>(){
        std::cout <<"\n";
    }

    template<int head, int... I>
    void print_props() {
        std::cout << FORMAT;
        std::cout << get_prop<head>() <<" "<< head <<"\t";
        print_props<I...>();
    }

}

#endif /*__PROPERTY_H__*/
